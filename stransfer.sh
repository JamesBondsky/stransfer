#!/usr/bin/env bash

# Default values
CONFIG=".stransfer.conf"
SSH_PORT=22
CLEAR_LOCAL_DIR=false
TRANSFER_METHOD=rsync
OLD_SSH_VERSION=false
# / Default values

function printUsage(){
    echo -e "\nUsage: ./site_transfer.sh -s <step> -f -h\n"
    echo -e "Keys:\n"
    echo "-s: select steps to run, allowed values: addStransferPubKey, copyDatabase or copyFiles"
    echo "-f: set a custom configuration file path, ./.stransfer.conf is used by default"
    echo "-h | --help: print help"
    echo -e "\nVariables for the configuration file:"
    echo "
TRANSFER_METHOD - the method of files transfering, rsync (by default) or scp
REMOTE_SSH_CONNECTION - the ssh connection string in a format <user>@<host>
AUTH_TYPE - a type of ssh authentification. Allowed values: stransferPubkey or sshpass. If the public key authentification is necessary, check the option PubkeyAuthentication isn't set to no in the sshd configuration
REMOTE_SSH_PASSWORD - the password for ssh conection. It's used when AUTH_TYPE is set to sshpass
SSH_PORT - the port of the ssh connection, it's set to 22 by default
LOCAL_PATH - the files' transfering aim directory on the local server
REMOTE_PATH - the files' transfering source directory on the remote server
CLEAR_LOCAL_DIR - if it set to true (by default), a local directory is cleared before files transfer
LOCAL_DB_NAME - a database name on the current server
LOCAL_DB_USER - a user with permissions to the local database
LOCAL_DB_PASSWORD - the local database user password
REMOTE_DB_NAME - a database name on the remote server
REMOTE_DB_USER - a user with permissions to the remote database
REMOTE_DB_PASSWORD - the remote database user password
LOCAL_DUMP_PATH - a temporary local directory for database dump
REMOTE_DUMP_PATH - a temporary remote directory for database dump
    ";
}

function printMessage() {
    if [ -z "$1" ]; then
        return 1
    fi
    echo -e "$1"
}

# Don't use numbers as arguments
function validate() {
    local STATUS=0
    for i in "$@"; do
        local TMP="${!i}"
        if [ -z "$TMP" ] || [ "$TMP" = "$i" ]; then
            printMessage "\t- $i";
            STATUS=1
        fi
    done
    return $STATUS
}

function checkSSHConnection(){
    local STATUS
    local CHECKED_AUTH_TYPE
    if [ -z "$1" ]; then
        CHECKED_AUTH_TYPE="$AUTH_TYPE";
    else
        CHECKED_AUTH_TYPE="$1";
    fi
    case "${CHECKED_AUTH_TYPE}" in
        stransferPubkey)
            STATUS=$(ssh -p "${SSH_PORT}" -i "$HOME/.ssh/stransfer" -o BatchMode=yes -o ConnectTimeout=5 "${REMOTE_SSH_CONNECTION}" echo ok 2>&1)
        ;;
        sshpass)
            STATUS=$(sshpass -p "${REMOTE_SSH_PASSWORD}" ssh -p "${SSH_PORT}" -o BatchMode=yes -o ConnectTimeout=5 "${REMOTE_SSH_CONNECTION}" echo ok 2>&1)
        ;;
        *)
            STATUS=$(ssh -p "${SSH_PORT}" -o BatchMode=yes -o ConnectTimeout=5 "${REMOTE_SSH_CONNECTION}" echo ok 2>&1)
        ;;
    esac
    if [[ $STATUS == ok ]]; then
        true
    else
        false
    fi
}

function runSSHCommand {
    if [ -z "$1" ]; then
        return 1;
    fi
    if [ -z "$2" ]; then
        COMMAND="$AUTH_TYPE";
    else
        COMMAND="$2";
    fi
    case "$COMMAND" in
        stransferPubkey)
            ssh -p "${SSH_PORT}" -i "$HOME/.ssh/stransfer"  -o BatchMode=yes -o ConnectTimeout=5 "${REMOTE_SSH_CONNECTION}" "$1"
        ;;
        sshpass)
            sshpass -p "${REMOTE_SSH_PASSWORD}" ssh -p "${SSH_PORT}"  -o BatchMode=yes -o ConnectTimeout=5 "${REMOTE_SSH_CONNECTION}" "$1"
        ;;
        *)
            ssh -p "${SSH_PORT}" -o BatchMode=yes -o ConnectTimeout=5 "${REMOTE_SSH_CONNECTION}" "$1"
        ;;
    esac
}

function addStransferPubKey(){
    if [ -z ${REMOTE_SSH_PASSWORD+x} ]; then
        local PASSWORD1 PASSWORD2 TMP_PASSWORD
        for i in {1..3}; do
            read -srep $'\nPlease, set a password for ssh connection: ' PASSWORD1
            read -srep $'\nConfirm the password: ' PASSWORD2
            if [[ $PASSWORD1 == "$PASSWORD2" ]]; then
                TMP_PASSWORD=$PASSWORD1
                break
            else
                printMessage "\nPasswords don't match"
            fi
        done
    else
        TMP_PASSWORD=$REMOTE_SSH_PASSWORD
    fi
    if [ -z ${TMP_PASSWORD+x} ]; then
        printMessage "\nThe password for ssh connection isn't set, operation is interrupted";
        return 1;
    fi
    printMessage "\nTrying to set ssh connection:";
    if ! checkSSHConnection "stransferPubkey"; then
        if [ ! -f "$HOME/.ssh/stransfer.pub" ]; then
            mkdir -m 700 -p "$HOME/.ssh/"
            ssh-keygen -t rsa -b 4096 -C "stransfer_autogenerated_key" -N "" -f "$HOME/.ssh/stransfer" -q
        fi
        sshpass -p "$TMP_PASSWORD" ssh -oStrictHostKeyChecking=no -p ${SSH_PORT} "$REMOTE_SSH_CONNECTION" "mkdir -m 700 -p ~/.ssh/"
        if [ $SSH_PORT == 22 ]; then
            sshpass -p "$TMP_PASSWORD" ssh-copy-id -i "$HOME/.ssh/stransfer.pub" "$REMOTE_SSH_CONNECTION"
        elif [ $OLD_SSH_VERSION == true ]
        then
            sshpass -p "$TMP_PASSWORD" ssh-copy-id -i "$HOME/.ssh/stransfer.pub" "-p $SSH_PORT $REMOTE_SSH_CONNECTION"
        else
            sshpass -p "$TMP_PASSWORD" ssh-copy-id -i "$HOME/.ssh/stransfer.pub" -p $SSH_PORT "$REMOTE_SSH_CONNECTION"
        fi
    else
        printMessage "SSH connection is already established, it doesn't have anything to do. Use AUTH_TYPE=stransferPubkey to ssh connection with the created public key"
        return 0
    fi
    if checkSSHConnection; then
        printMessage "The SSH connection was successfully established. Use AUTH_TYPE=stransferPubkey to ssh connection with the created public key"
        return 0
    else
        printMessage "Can't establish connection"
        return 1
    fi
}

function transfer(){
    if [ -z "$1" ] || [ -z "$2" ]; then
        return 1;
    fi
    if [[ $TRANSFER_METHOD == scp ]]; then
        case "$AUTH_TYPE" in
            stransferPubkey)
                scp -P ${SSH_PORT} -i "$HOME/.ssh/stransfer" -r "$REMOTE_SSH_CONNECTION:$1". "$2"
            ;;
            sshpass)
                sshpass -p "${REMOTE_SSH_PASSWORD}" scp -P ${SSH_PORT} -r "$REMOTE_SSH_CONNECTION:$1". "$2"
            ;;
            *)
                scp -P ${SSH_PORT} -r "$REMOTE_SSH_CONNECTION:$1". "$2"
            ;;
        esac
    else
        case "$AUTH_TYPE" in
            stransferPubkey)
                rsync -chazP --stats --rsh="ssh -i $HOME/.ssh/stransfer -p"${SSH_PORT} "$REMOTE_SSH_CONNECTION:$1". "$2"
            ;;
            sshpass)
                sshpass -p rsync -chazP --stats --rsh="ssh -p"${SSH_PORT} "$REMOTE_SSH_CONNECTION:$1". "$2"
            ;;
            *)
                rsync -chazP --stats --rsh="ssh -p"${SSH_PORT} "$REMOTE_SSH_CONNECTION:$1". "$2"
            ;;
        esac
    fi
}

function copyDatabase() {
    local VALIDATION_OUTPUT
    VALIDATION_OUTPUT=$(validate LOCAL_DB_NAME LOCAL_DB_USER LOCAL_DB_PASSWORD REMOTE_DB_NAME REMOTE_DB_USER REMOTE_DB_PASSWORD LOCAL_DUMP_PATH REMOTE_DUMP_PATH REMOTE_SSH_CONNECTION)
    if [ $? -ne 0 ]; then
        printMessage "Necessary options aren't set: \n${VALIDATION_OUTPUT}"
    else
        printMessage "A database dump creating:"
        runSSHCommand "mkdir -p ${REMOTE_DUMP_PATH} && mysqldump -u ${REMOTE_DB_USER} --password=${REMOTE_DB_PASSWORD} ${REMOTE_DB_NAME} > ${REMOTE_DUMP_PATH}dump.sql"
        if runSSHCommand "test -f ${REMOTE_DUMP_PATH}dump.sql" ; then
            printMessage "The dump is successfully created\nTrying to transfer the dump:"
            transfer ${REMOTE_DUMP_PATH} ${LOCAL_DUMP_PATH}
            if [ -f "${LOCAL_DUMP_PATH}dump.sql" ]; then
                printMessage "The dump is successfully transfered\nTrying to import the dump:"
                mysql -u ${LOCAL_DB_USER} --password=${LOCAL_DB_PASSWORD} -e "CREATE DATABASE IF NOT EXISTS ${LOCAL_DB_NAME}"
                mysql -u ${LOCAL_DB_USER} --password=${LOCAL_DB_PASSWORD} ${LOCAL_DB_NAME} < ${LOCAL_DUMP_PATH}dump.sql
                if [ $? -ne 0 ]; then
                    printMessage "The dump isn't imported"
                else
                    printMessage "The dump is imported"
                fi
                rm -r "$LOCAL_DUMP_PATH"
                runSSHCommand "rm -r ${REMOTE_DUMP_PATH}"
            else
                printMessage "The dump isn't transfered, the operation is stoped"
                return 1;
            fi
        else
            printMessage "The dump isn't created, the operation is stoped"
            return 1;
        fi
        
    fi
}

function copyFiles() {
    local VALIDATION_OUTPUT
    VALIDATION_OUTPUT=$(validate REMOTE_PATH LOCAL_PATH REMOTE_SSH_CONNECTION)
    if [ $? -ne 0 ]; then
        printMessage "Necessary options aren't set: \n${VALIDATION_OUTPUT}"
        printMessage "Please, set this options in your configuration file and repeat the operation"
    else
        if [[ $CLEAR_LOCAL_DIR == true ]]; then
            find "${LOCAL_PATH}" -mindepth 1 -exec rm -rf {} \;
        fi
        transfer "$REMOTE_PATH" "$LOCAL_PATH"
    fi
}

function operationTitle() {
    local OPERATION_TITLE
    if [ -z "$1" ]; then
        OPERATION_TITLE="A selected operation"
    else
        OPERATION_TITLE="The operation \"$1\""
    fi
    clear
    printMessage "\n"
    printf %"$(tput cols)"s |tr " " "-"
    printMessage "$OPERATION_TITLE is run\n"
}

function operationEpilog() {
    printMessage "\nDone."
    printf %"$(tput cols)"s |tr " " "-"
    printMessage "\n"
}

function mainScreen() {
    local OPERATION
    clear
    printMessage "\n\t\tAllowed operations:\n"
    printMessage "\t\t1. Create a rsa public key and add it to the remote server"
    printMessage "\t\t2. Copy files from the remote server using rsync or scp"
    printMessage "\t\t3. Copy database from the remote server"
    printMessage "\t\t4. Exit\n"
    read -rep $'\t\tEnter your choice: ' OPERATION
    case "$OPERATION" in
        1)
            operationTitle "addStransferPubKey"
            addStransferPubKey
            operationEpilog
        ;;
        2)
            operationTitle "copyFiles"
            copyFiles
            operationEpilog
        ;;
        3)
            operationTitle "copyDatabase"
            copyDatabase
            operationEpilog
        ;;
        4)
            printMessage "\n"
            exit 0
        ;;
        *)
            printMessage "\n\t\tOperation doesn't found.\n"
        ;;
    esac
    read -rep $'\t\tEnter anything to return at the menu: ' OPERATION
    printMessage "\n"
    mainScreen
}

while getopts 'f:s:h-:' flag; do
    case "${flag}" in
        -)
            case "${OPTARG}" in
                *)
                    printUsage
                    exit 1
                ;;
        esac;;
        s)
            STEPS+=("$OPTARG")
        ;;
        f)
            CONFIG="${OPTARG}"
        ;;
        h)
            printUsage
            exit 1
        ;;
        *)
            printUsage
            exit 1
        ;;
    esac
done

. $(readlink -f "$CONFIG")

if [ ${#STEPS[@]} -ne 0 ]; then
    for i in "${STEPS[@]}"
    do
        if [ "$i" == "addStransferPubKey" ]; then
            operationTitle "addStransferPubKey"
            addStransferPubKey
            operationEpilog
        elif [ "$i" == "copyDatabase" ]
        then
            operationTitle "copyDatabase"
            copyDatabase
            operationEpilog
        elif [ "$i" == "copyFiles" ]
        then
            operationTitle "copyFiles"
            copyFiles
            operationEpilog
        fi
    done
else
    mainScreen
fi